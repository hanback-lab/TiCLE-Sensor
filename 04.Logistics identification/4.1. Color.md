# Color Sensor  
Color Sensor(컬러 센서)는 주변 빛의 **RGB(빨강, 초록, 파랑)** 성분과 **Clear(명도)** 값을 측정하여, 물체의 색상을 인식할 수 있는 센서입니다.  
본 실습에서는 **APDS9960** 센서를 사용합니다. 이 센서는 색상 감지 외에도 근접(Proximity) 및 제스처(Gesture) 인식 기능을 지원하지만, 이번 실습에서는 **색상 감지(Color Sensing)** 부분을 중심으로 다룹니다.  

센서 내부에는 다음과 같은 기능이 포함되어 있습니다.  
- RGB + Clear(투명광) 감지용 포토다이오드  
- 자동 이득 조절(AGC) 기능  
- 통합 시간 설정(Integration Time)  
- 주변광 감지 인터럽트 기능  
- I²C 통신 인터페이스  

이 센서를 이용하면 조명 색상을 측정하거나, 물체의 색깔을 인식하여 분류하는 응용을 구현할 수 있습니다.

## Color Sensor 레지스터 
APDS9960은 내부의 여러 **레지스터(Register)** 를 통해 동작 모드와 설정 값을 제어합니다.  
마이크로컨트롤러는 I²C 통신을 통해 이 레지스터에 접근합니다.  
대표적인 제어 및 상태 레지스터의 기능은 아래와 같습니다.

| 레지스터명 | 주소(HEX) | 기능 설명 |
|---|---|---|
| **ENABLE** | 0x80 | 센서의 전원 및 각 기능을 ON/OFF 합니다. <br>비트 구성: <br> - Bit 0: PON (전원 공급) <br> - Bit 1: AEN (ALS 활성화) <br> - Bit 3: WEN (Wait 기능) <br> - Bit 4: AIEN (ALS 인터럽트) |
| **ATIME** | 0x81 | 적분 시간(Integration Time)을 설정합니다. <br>하나의 측정 사이클이 얼마나 긴 시간 동안 빛을 수집할지를 결정합니다. |
| **WTIME** | 0x83 | Wait 상태 지속 시간을 설정합니다. 주로 절전 모드에서 사용됩니다. |
| **CONTROL** | 0x8F | 증폭 이득(Gain)을 설정합니다. <br>값이 클수록 어두운 환경에서도 감도가 증가합니다. (예: 1x, 4x, 16x, 64x) |
| **STATUS** | 0x93 | 데이터 준비 여부를 나타내는 상태 플래그를 포함합니다. <br>Bit0 = AVALID: 새 데이터가 준비됨 |
| **CDATAL~BDATAH** | 0x94~0x9B | Clear, Red, Green, Blue 각 색상의 16비트 데이터가 저장되는 영역입니다. <br>각 색상은 LSB와 MSB(상위/하위 바이트)로 구성됩니다. |
| **ID** | 0x92 | 칩의 고유 ID를 저장하는 읽기 전용 레지스터입니다. 센서 인식 확인용으로 사용됩니다. |

## Color Sensor 연결 구성 

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| GP0 | SDA | I2C 데이터 |
| GP1 | SCL | I2C 클록 |
| GP15 | INT | (선택) 인터럽트 입력 |
| GP14 | LED | (선택) LED 조명 제어 |

![Color Connection](res/color%20connection.png)

## Color Sensor 제어 코드 

```python
from machine import I2C, Pin
import time
import utime

class Color:
    I2C_ADDR = 0x39

    REG_ENABLE   = 0x80
    REG_ATIME    = 0x81
    REG_WTIME    = 0x83
    REG_AILTL    = 0x84
    REG_AILTH    = 0x85
    REG_AIHTL    = 0x86
    REG_AIHTH    = 0x87
    REG_PERS     = 0x8C
    REG_CONFIG1  = 0x8D
    REG_CONTROL  = 0x8F
    REG_ID       = 0x92
    REG_STATUS   = 0x93
    REG_CDATAL   = 0x94

    PON  = 0x01
    AEN  = 0x02
    WEN  = 0x08
    AIEN = 0x10

    def __init__(self, i2c: I2C, addr: int = I2C_ADDR, led_pin: int | None = None,
                 int_pin: int | None = None, use_int: bool = False):
        self.i2c = i2c
        self.addr = addr
        self.led = Pin(led_pin, Pin.OUT) if led_pin is not None else None
        self.int_pin = Pin(int_pin, Pin.IN, Pin.PULL_UP) if int_pin is not None else None
        self._int_flag = False
        if self.int_pin and use_int:
            self.int_pin.irq(trigger=Pin.IRQ_FALLING, handler=self._irq_handler)

        try:
            chip_id = self._r8(self.REG_ID)
        except OSError:
            raise OSError("APDS9960 not found on I2C. Check wiring and address (0x39).")
        if chip_id in (0x00, 0xFF):
            raise OSError("APDS9960 unexpected ID: 0x%02X" % chip_id)

        self._w8(self.REG_ENABLE, self.PON)
        time.sleep_ms(5)

        self.set_integration_time_ms(100)
        self.set_gain(again=1)
        self.disable_als_interrupt()
        self._w8(self.REG_ENABLE, self.PON | self.AEN)
        self._led_on(True)

    def _w8(self, reg, val):
        self.i2c.writeto_mem(self.addr, reg, bytes([val & 0xFF]))

    def _r8(self, reg):
        return self.i2c.readfrom_mem(self.addr, reg, 1)[0]

    def _r16(self, reg_lsb):
        b = self.i2c.readfrom_mem(self.addr, reg_lsb, 2)
        return b[0] | (b[1] << 8)

    def set_integration_time_ms(self, ms: int):
        if ms < 3: ms = 3
        if ms > 700: ms = 700
        cycles = int(round(ms / 2.78))
        if cycles < 1: cycles = 1
        if cycles > 255: cycles = 255
        atime = (256 - cycles) & 0xFF
        self._w8(self.REG_ATIME, atime)
        self._atime_ms = cycles * 2.78

    def set_gain(self, again: int = 1):
        again &= 0x03
        self._w8(self.REG_CONTROL, again)
        self._again = again

    def enable_als_interrupt(self, low_thr=0x0000, high_thr=0xFFFF, persistence=1):
        self._w8(self.REG_AILTL, low_thr & 0xFF)
        self._w8(self.REG_AILTH, (low_thr >> 8) & 0xFF)
        self._w8(self.REG_AIHTL, high_thr & 0xFF)
        self._w8(self.REG_AIHTH, (high_thr >> 8) & 0xFF)
        self._w8(self.REG_PERS, persistence & 0x0F)
        en = self._r8(self.REG_ENABLE)
        self._w8(self.REG_ENABLE, en | self.AIEN)

    def disable_als_interrupt(self):
        en = self._r8(self.REG_ENABLE)
        self._w8(self.REG_ENABLE, en & (~self.AIEN & 0xFF))

    def clear_als_interrupt(self):
        try:
            self.i2c.writeto(self.addr, bytes([0xE7]))
        except:
            pass

    def data_ready(self):
        st = self._r8(self.REG_STATUS)
        return (st & 0x01) != 0

    def _irq_handler(self, pin):
        self._int_flag = True

    def _led_on(self, on=True):
        if self.led is not None:
            self.led.value(1 if on else 0)

    def read_raw_once(self, use_int_wait=False, int_timeout_ms=500):
        t0 = utime.ticks_ms()
        self._int_flag = False

        while True:
            if use_int_wait and self.int_pin is not None:
                if self._int_flag or self.int_pin.value() == 0:
                    break
            else:
                if self.data_ready():
                    break
            if utime.ticks_diff(utime.ticks_ms(), t0) > int_timeout_ms:
                break
            time.sleep_ms(2)

        c = self._r16(self.REG_CDATAL)
        r = self._r16(self.REG_CDATAL + 2)
        g = self._r16(self.REG_CDATAL + 4)
        b = self._r16(self.REG_CDATAL + 6)

        self.clear_als_interrupt()
        return c, r, g, b

    @staticmethod
    def normalize_rgb8(c, r, g, b):
        if c <= 1:
            m = max(r, g, b, 1)
            rn = int(255 * r / m)
            gn = int(255 * g / m)
            bn = int(255 * b / m)
        else:
            rn = int(255 * r / c)
            gn = int(255 * g / c)
            bn = int(255 * b / c)

        rn = 0 if rn < 0 else 255 if rn > 255 else rn
        gn = 0 if gn < 0 else 255 if gn > 255 else gn
        bn = 0 if bn < 0 else 255 if bn > 255 else bn
        return rn, gn, bn

    @staticmethod
    def guess_color_name(r8, g8, b8):
        r, g, b = r8/255.0, g8/255.0, b8/255.0
        mx, mn = max(r, g, b), min(r, g, b)
        if mx < 0.08:
            return "black"
        if mx - mn < 0.08:
            return "gray/white"
        if mx == r:
            return "red" if g < 0.5 and b < 0.5 else "yellow/orange"
        if mx == g:
            return "green"
        return "blue/purple"

def main():
    I2C_ID = 0
    PIN_SDA = 0
    PIN_SCL = 1
    PIN_LED = 14
    PIN_INT = 15

    i2c = I2C(I2C_ID, sda=Pin(PIN_SDA), scl=Pin(PIN_SCL), freq=400_000)

    try:
        sensor = Color(i2c, led_pin=PIN_LED, int_pin=PIN_INT, use_int=False)
    except Exception as e:
        print("Init failed:", e)
        return

    print("APDS9960 color demo. Press Ctrl+C to stop.")
    print("LED turns ON while waiting/reading a sample.")

    while True:
        try:
            c, r, g, b = sensor.read_raw_once(use_int_wait=False)
            r8, g8, b8 = Color.normalize_rgb8(c, r, g, b)
            name = Color.guess_color_name(r8, g8, b8)
            print("C={}  R={}  G={}  B={}  | RGB8=({}, {}, {})  -> {}".format(c, r, g, b, r8, g8, b8, name))
            time.sleep(0.2)
        except KeyboardInterrupt:
            print("\nStop.")
            break
        except OSError as e:
            print("I2C error:", e)
            time.sleep(0.3)

if __name__ == "__main__":
    main()

```


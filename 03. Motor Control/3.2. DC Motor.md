# DC Motor
DC 모터(Direct Current Motor)는 **직류 전원을 입력받아 회전 운동을 하는 가장 기본적인 형태의 구동 모터**입니다.  
전류의 방향에 따라 회전 방향이 바뀌며, 입력되는 전압이나 PWM 듀티비를 조절함으로써 **회전 속도**를 제어할 수 있습니다.  

## DC Motor 원리 
DC 모터는 내부의 브러시(Brush)와 정류자(Commutator)를 통해 코일에 전류를 공급하고,  
자기장의 상호작용으로 회전력이 발생하는 구조를 가지고 있습니다.  

- **전류 방향**이 바뀌면 **회전 방향**도 반대로 바뀝니다.  
- **공급 전압의 크기**에 따라 **속도**가 결정됩니다.  
- **PWM 제어**를 통해 아날로그적인 속도 제어가 가능합니다.  

## DC DRV + DC Motor 연결 구성 
| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 12V | +12V | 전원 |
| GND | GND | 접지 |
| GP27 | EN | PWM 제어 |
| GP12 | A | 방향 제어 입력 1 |
| GP13 | B | 방향 제어 입력 2 |
| GP14 | ENC1 | 엔코더 A상 입력 |
| GP15 | ENC2 | 엔코더 B상 입력 |

![DC Connection](res/dc%20connection.png)

## DC Motor 제어 코드 
```python
from machine import Pin
import time

EN  = Pin(27, Pin.OUT, value=1)
IN1 = Pin(12, Pin.OUT, value=0)
IN2 = Pin(13, Pin.OUT, value=0)

def forward():
    EN.value(1)
    IN1.value(1)
    IN2.value(0)

def reverse():
    EN.value(1)
    IN1.value(0)
    IN2.value(1)

def stop():
    EN.value(0)
    IN1.value(0)
    IN2.value(0)

print("FORWARD 3s")
forward()
time.sleep(3)
print("STOP 1s")
stop()
time.sleep(1)
print("REVERSE 3s")
reverse()
time.sleep(3)
stop()
```

```python
from machine import Pin, PWM
import utime

STOP = 0
FORWARD = 1
BACKWARD = 2

EN  = PWM(Pin(27), 5000)
IN1 = Pin(12, Pin.OUT, value=0)
IN2 = Pin(13, Pin.OUT, value=0)

def drive(percent, direction):
    if percent > 100: 
        percent = 100
    if percent < -100: 
        percent = -100
    mag = abs(percent)
    d = int(mag * 65535 // 100)
    if direction == FORWARD:
        IN1.value(1)
        IN2.value(0)
    elif direction == BACKWARD:
        IN1.value(0)
        IN2.value(1)
    elif direction == STOP:
        IN1.value(0)
        IN2.value(0)
    EN.duty_u16(d)

for i in range(100):
    drive(i,FORWARD)
    utime.sleep_ms(100)
for i in range(100):
    drive(100-i,FORWARD)
    utime.sleep_ms(100)
for i in range(100):
    drive(i*-1,BACKWARD)
    utime.sleep_ms(100)
for i in range(100):
    drive(-100-i*-1,BACKWARD)
    utime.sleep_ms(100)
drive(0,STOP)
```

## Encoder 
엔코더는 **모터의 회전 각도나 속도를 전기 신호(펄스)** 로 바꿔주는 센서입니다.  
쉽게 말해, 모터가 얼마나 돌았는지 또는 얼마나 빠르게 도는지를 알려주는 역할을 합니다.  
DC 모터나 서보모터의 **정확한 제어(피드백)** 를 위해 반드시 필요한 센서입니다.

### Encoder 의 기본 원리
엔코더는 모터 축에 연결된 **디스크**와 **광센서(또는 자기센서)** 로 구성되어 있습니다.

- **광학식(Optical Encoder)**  
  회전 디스크에 미세한 투과/불투과 무늬가 새겨져 있고,  
  회전하면서 빛이 차단되거나 통과할 때 신호가 펄스 형태로 발생합니다.

- **자기식(Magnetic Encoder)**  
  자석과 홀 센서를 이용해 자속 변화로 회전 신호를 감지합니다.

디스크의 무늬가 **한 칸 지나갈 때마다 1펄스**가 발생하며, 이 펄스가 곧 **회전량**이 됩니다.
즉, 펄스 개수를 세면 얼마나 돌았는지(회전각) 알 수 있고, 펄스가 발생하는 속도를 측정하면 얼마나 빠르게 도는지(속도)를 알 수 있습니다.

```python
from machine import Pin, PWM
import utime

STOP = 0
FORWARD = 1
BACKWARD = 2

EN  = PWM(Pin(27), 5000)
IN1 = Pin(12, Pin.OUT, value=0)
IN2 = Pin(13, Pin.OUT, value=0)
enc_a = Pin(14, Pin.IN, Pin.PULL_UP)
count = 0

def drive(percent, direction):
    if percent > 100: 
        percent = 100
    if percent < -100: 
        percent = -100
    mag = abs(percent)
    d = int(mag * 65535 // 100)
    if direction == FORWARD:
        IN1.value(1)
        IN2.value(0)
    elif direction == BACKWARD:
        IN1.value(0)
        IN2.value(1)
    elif direction == STOP:
        IN1.value(0)
        IN2.value(0)
    EN.duty_u16(d)

def enc_irq(pin):
    global count 
    count += 1
    
enc_a.irq(enc_irq, Pin.IRQ_RISING | Pin.IRQ_FALLING)

for i in range(100):
    drive(i,FORWARD)
    print("count =", count)
    utime.sleep_ms(200)
drive(0,STOP)
```

```python
from machine import Pin, PWM
import utime

STOP, FORWARD, BACKWARD = 0, 1, 2
EN  = PWM(Pin(27), 5000)
IN1 = Pin(12, Pin.OUT, value=0)
IN2 = Pin(13, Pin.OUT, value=0)

def drive(percent, direction):
    if percent > 100:  percent = 100
    if percent < -100: percent = -100
    d = int(abs(percent) * 65535 // 100)
    if direction == FORWARD:
        IN1.value(1); IN2.value(0)
    elif direction == BACKWARD:
        IN1.value(0); IN2.value(1)
    else:
        IN1.value(0); IN2.value(0)
    EN.duty_u16(d)

enc_a = Pin(14, Pin.IN, Pin.PULL_UP)
enc_b = Pin(15, Pin.IN, Pin.PULL_UP)

count = 0

def enc_irq(pin):
    global count 
    count += 1

enc_a.irq(enc_irq, Pin.IRQ_RISING | Pin.IRQ_FALLING)
enc_b.irq(enc_irq, Pin.IRQ_RISING | Pin.IRQ_FALLING)

for i in range(100):
    drive(i,FORWARD)
    print("count =", count)
    utime.sleep_ms(200)
drive(0, STOP)
```

```python
from machine import Pin, PWM
import utime

STOP, FORWARD, BACKWARD = 0, 1, 2
EN  = PWM(Pin(27), 5000)
IN1 = Pin(12, Pin.OUT, value=0)
IN2 = Pin(13, Pin.OUT, value=0)

def drive(percent, direction):
    global last_dir
    if percent > 100:  percent = 100
    if percent < -100: percent = -100
    d = int(abs(percent) * 65535 // 100)

    if direction == FORWARD:
        IN1.value(1); IN2.value(0)
    elif direction == BACKWARD:
        IN1.value(0); IN2.value(1)
    else:
        IN1.value(0); IN2.value(0)
        last_dir = 0

    EN.duty_u16(d)

enc_a = Pin(14, Pin.IN, Pin.PULL_UP)
enc_b = Pin(15, Pin.IN, Pin.PULL_UP)

DIR_SIGN = +1
DEBOUNCE_US = 120

count = 0
last_dir = 0
_last_a = enc_a.value()
_last_us = utime.ticks_us()

def enc_irq(pin):
    global count, last_dir, _last_a, _last_us
    now = utime.ticks_us()
    if utime.ticks_diff(now, _last_us) < DEBOUNCE_US:
        return
    _last_us = now

    a = enc_a.value()
    if _last_a == 0 and a == 1:
        b = enc_b.value()
        delta = +1 if b == 0 else -1
        delta *= DIR_SIGN
        count += delta
        last_dir = 1 if delta > 0 else -1
    _last_a = a

enc_a.irq(enc_irq, Pin.IRQ_RISING | Pin.IRQ_FALLING)

def dir_text_from_counts(prev_cnt, curr_cnt, fallback_dir):
    if curr_cnt == prev_cnt:
        return "STOP"
    return "FWD" if curr_cnt > prev_cnt else "REV"

try:
    prev_cnt = count
    for i in range(0, 100, 2):
        drive(i, FORWARD)
        utime.sleep_ms(200)
        curr_cnt = count
        dir_str = dir_text_from_counts(prev_cnt, curr_cnt, last_dir)
        print(f"dir={dir_str:4s}  count={curr_cnt:8d}")
        prev_cnt = curr_cnt

    for i in range(0, 100, 2):
        drive(100-i, BACKWARD)
        utime.sleep_ms(200)
        curr_cnt = count
        dir_str = dir_text_from_counts(prev_cnt, curr_cnt, last_dir)
        print(f"dir={dir_str:4s}  count={curr_cnt:8d}")
        prev_cnt = curr_cnt

finally:
    drive(0, STOP)
```
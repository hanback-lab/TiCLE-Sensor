# IMU Sensor  
IMU(관성 측정 장치, Inertial Measurement Unit) 센서는 가속도계(Accelerometer), 자이로스코프(Gyroscope), 지자기계(Magnetometer) 등을 결합하여 물체의 회전, 기울기, 방향, 속도 변화 등을 감지하는 센서입니다.

IMU는 스마트폰, 드론, 로봇, 자율주행 차량 등 다양한 분야에서 사용됩니다.
특히 BNO055는 내부에 9축 센서와 Fusion 알고리즘이 내장되어 있어, 복잡한 계산 없이 바로 Euler 각(roll, pitch, yaw) 나 Quaternion 데이터를 얻을 수 있습니다.

![IMU Sensor]()

## 9축 센서 구성 
| 센서 | 측정 대상 | 단위 | 설명 |
|---|---|---|---|
| 가속도계 (Accelerometer) | 선형 가속도 | m/s² |X, Y, Z 축 방향으로의 직선 가속도를 측정합니다. 중력 가속도(9.81 m/s²)도 포함되어 있습니다. |
| 자이로스코프 (Gyroscope) | 각속도 | °/s (dps) | 회전의 빠르기(초당 몇 도 회전했는가)를 측정합니다. 드론이나 로봇 팔의 회전 안정화에 사용됩니다. |
| 지자기계 (Magnetometer) | 자기장 방향 | µT | 지구 자기장을 측정하여 북쪽 방향을 기준으로 회전 각(heading)을 계산합니다. 나침반과 같은 역할입니다. |

이 세 센서의 데이터를 **센서 융합(Fusion Algorithm)**을 통해 결합하면 보다 안정적이고 잡음이 적은 자세(orientation) 정보를 얻을 수 있습니다.

## Euler Angle과 Quaternion 
IMU는 물체의 회전 상태를 표현하기 위해 두 가지 방식의 데이터를 제공합니다.

### Euler Angler(오일러 각)
- Heading(Yaw): 북쪽을 기준으로 한 회전 각도 (좌/우 회전)
- Roll: 좌우로 기울어진 각도 (비행기 날개처럼)
- Pitch: 앞뒤로 기울어진 각도 (비행기 머리 들기/내리기)

### Quaternion(쿼터니언)
Quaternion은 4개의 값 (w, x, y, z) 으로 회전을 표현하는 수학적 방식입니다.
3D 회전을 하나의 단일 회전 벡터로 나타낼 수 있으며, 짐벌락이 발생하지 않고 회전이 매우 부드럽습니다.
- w: 회전의 크기와 방향을 함께 표현하는 실수 부분
- x, y, z: 회전 축의 방향을 나타내는 벡터 부분

## BNO055 센서의 특징 
Bosch사의 BNO055는 내부에 3축 가속도계,3축 자이로스코프,3축 지자기계 를 포함하며, 내부 MCU가 이 데이터를 자동으로 융합하여 NDOF 모드(9자유도 Fused Data)를 제공합니다.
즉, 사용자는 복잡한 수식을 직접 계산하지 않고도 Euler Angle이나 Quaternion을 바로 읽을 수 있습니다.

### 주요 레지스터 
여기서 칩의 전체 레지스터를 설명하지는 않습니다. 필수 몇가지만 설명하며, 필요한 경우 칩의 데이터 시트를 찾아보시기 바랍니다. 

| 레지스터 주소 | 이름 | 내용 | 단위/비트 | 설명 |
|---|---|---|---|---|
| 0x00 | CHIP_ID | 칩 식별 ID (0xA0) | - | 센서 확인용| 
| 0x08 | ACC_DATA_X_LSB | 가속도 데이터 시작 주소 | 1 LSB = 1/100 m/s² | 6바이트(각 축 2바이트) | 
| 0x14 | GYR_DATA_X_LSB | 자이로 데이터 시작 주소 | 1 LSB = 1/16 dps | 6바이트(각 축 2바이트) | 
| 0x1A | EUL_HEADING_LSB | 오일러 각 데이터 | 1 LSB = 1/16 ° | Heading, Roll, Pitch 순 | 
| 0x20 | QUA_DATA_W_LSB | 쿼터니언 데이터 | 1 LSB = 1/16384 | W, X, Y, Z 순 |
| 0x28 | LIA_DATA_X_LSB | 선형 가속도 | 1 LSB = 1/100 m/s² | 중력 제거된 가속도 | 
| 0x34 | TEMP | 내부 온도 | °C | - |
| 0x35 | CALIB_STAT | 보정 상태 | 8비트 |SYS/GYR/ACC/MAG 각 2비트 | 
| 0x3D | OPR_MODE | 동작 모드 설정 | - | NDOF(0x0C), IMU(0x08) 등 |
| 0x3B | UNIT_SEL | 단위 설정 | - | °/rad, m/s²/mg, °C/°F 등 선택 |
| 0x3E | PWR_MODE | 전원 모드 | - | Normal / Low / Suspend |


## IMU Sensor 연결 구성 

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| GP0 | SDA | I2C 데이터 |
| GP1 | SCL | I2C 클록 |

![IMU Connection](res/imu%20connection.png)

## IMU Sensor 제어 코드 

```python
from machine import I2C, Pin
import time
import struct

class BNO055:
    ADDR_A = 0x28
    ADDR_B = 0x29
    CHIP_ID = 0x00
    EUL_HEADING_LSB = 0x1A
    QUA_W_LSB = 0x20
    LIA_DATA_LSB = 0x28
    GRV_DATA_LSB = 0x2E
    TEMP = 0x34
    CALIB_STAT = 0x35
    OPR_MODE = 0x3D
    UNIT_SEL = 0x3B
    MODE_NDOF = 0x0C

    def __init__(self, i2c: I2C, addr=None):
        scan = i2c.scan()
        if 0x28 in scan:
            self.addr = 0x28
        elif 0x29 in scan:
            self.addr = 0x29
        else:
            raise OSError("BNO055 not found on I2C bus.")
        self.i2c = i2c
        self._write(self.OPR_MODE, self.MODE_NDOF)
        self._write(self.UNIT_SEL, 0x00)
        time.sleep_ms(50)

    def _read(self, reg, n=1):
        return self.i2c.readfrom_mem(self.addr, reg, n)

    def _write(self, reg, val):
        self.i2c.writeto_mem(self.addr, reg, bytes([val]))

    def euler(self):
        data = self._read(self.EUL_HEADING_LSB, 6)
        h, r, p = struct.unpack("<hhh", data)
        return (h / 16.0, r / 16.0, p / 16.0)

    def accel(self):
        data = self._read(self.LIA_DATA_LSB, 6)
        x, y, z = struct.unpack("<hhh", data)
        return (x / 100.0, y / 100.0, z / 100.0)

    def temperature(self):
        t = self._read(self.TEMP, 1)[0]
        return t if t < 128 else t - 256

def main():
    i2c = I2C(0, sda=Pin(0), scl=Pin(1), freq=400000)
    imu = BNO055(i2c)
    print("IMU initialized.")
    while True:
        h, r, p = imu.euler()
        ax, ay, az = imu.accel()
        t = imu.temperature()
        print(f"H:{h:.1f}° R:{r:.1f}° P:{p:.1f}° | "
              f"AX:{ax:.2f} AY:{ay:.2f} AZ:{az:.2f} m/s² | T:{t}°C")
        time.sleep(0.5)

if __name__ == "__main__":
    main()
```

## 기울기 경보 구현 

```python
from machine import I2C, Pin
import time, struct
from imu_simple import BNO055  # 위의 클래스 저장 후 import

buzzer = Pin(15, Pin.OUT)
i2c = I2C(0, sda=Pin(0), scl=Pin(1), freq=400000)
imu = BNO055(i2c)

THRESHOLD = 30  # 기울기 경계값 (deg)

while True:
    _, roll, pitch = imu.euler()
    if abs(roll) > THRESHOLD or abs(pitch) > THRESHOLD:
        buzzer.on()
        print("⚠️ Tilt detected!")
    else:
        buzzer.off()
    time.sleep(0.2)

```


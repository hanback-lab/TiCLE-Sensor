# Pixel Display 
NeoPixel은 WS2812라는 칩이 내장된 RGB LED로, 하나의 데이터 선만으로 다수의 LED를 개별 제어할 수 있는 매우 효율적인 구조를 가지고 있습니다.

이 LED들은 픽셀 단위로 색상과 밝기를 조절할 수 있어, 디지털 아트, 간단한 디스플레이, 센서 시각화 등에 널리 활용됩니다.

Pixel Display 제어에 사용되는 WS2812 는 내부에 마이크로컨트롤러와 세 개의 컬러 다이오드(R, G, B) 를 포함한 지능형 LED입니다.각 LED는 24비트(8비트 × 3채널) 색상 데이터를 받으며, 데이터 신호가 직렬로 다음 LED로 전달됩니다. 3채널의 색상 데이터는 0~255 범위를 가집니다. 

데이터 전송은 매우 짧은 타이밍 간격으로 구분되며, MCU(마이크로컨트롤러)는 이를 정확히 맞춰야 합니다.
MicroPython의 neopixel 라이브러리는 이 과정을 하드웨어 레벨에서 자동으로 처리해주므로, 사용자는 간단히 (R, G, B) 값만 지정하면 됩니다.

## Pixel Display 연결 구성 

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| GP16 | Data | Pixel Display Data |

![Pixel Display Connection](res/pixel%20connection.png)

## Pixel Display 기본 제어 
아래 코드는 Pixel Display 전체를 하나의 색상으로 채우거나 초기화하는 가장 기본적인 예제입니다.

```python
from machine import Pin
from rp2 import PIO, StateMachine, asm_pio
import time

@asm_pio(
    sideset_init=PIO.OUT_LOW,
    out_shiftdir=PIO.SHIFT_LEFT,
    autopull=True,
    pull_thresh=24
)
def ws2812():
    T1 = 2
    T2 = 5
    T3 = 3
    wrap_target()
    label("bitloop")
    out(x, 1)               .side(0) [T3 - 1]
    jmp(not_x, "do_zero")   .side(1) [T1 - 1]
    jmp("bitloop")          .side(1) [T2 - 1]
    label("do_zero")
    nop()                   .side(0) [T2 - 1]
    wrap()

class WS2812MatrixPIO:
    def __init__(self, pin, width=8, height=8, sm_id=0, freq=8_000_000):
        self.width, self.height = width, height
        self.buf = bytearray(width * height * 3)
        self.sm = StateMachine(sm_id, ws2812, freq=freq, sideset_base=Pin(pin))
        self.sm.active(1)

    def _idx(self, x, y):
        return (y * self.width + x) * 3

    def __setitem__(self, xy, rgb):
        x, y = xy
        r, g, b = rgb
        i = self._idx(x, y)
        self.buf[i + 0] = g & 0xFF
        self.buf[i + 1] = r & 0xFF
        self.buf[i + 2] = b & 0xFF

    def clear(self):
        for i in range(len(self.buf)):
            self.buf[i] = 0

    def show(self):
        mv = memoryview(self.buf)
        for i in range(0, len(mv), 3):
            v = (mv[i] << 16) | (mv[i + 1] << 8) | mv[i + 2]
            self.sm.put(v, 8)
        time.sleep_us(300)

matrix = WS2812MatrixPIO(pin=16, width=8, height=8)
matrix.clear()

for i in range(8):
    for j in range(8):
        matrix[i,j] = (255,0,0)
matrix.show()
time.sleep(3)

for i in range(8):
    for j in range(8):
        matrix[i,j] = (0,255,0)
matrix.show()
time.sleep(3)

for i in range(8):
    for j in range(8):
        matrix[i,j] = (0,0,255)
matrix.show()
time.sleep(3)

matrix.clear()
matrix.show()
```


## 무지개 효과 출력 
Pixel Display 의 장점은 각 LED에 다른 색을 순서대로 출력할 수 있다는 점입니다.
아래 예제는 8×8 디스플레이 전체에 무지개 효과를 만들어줍니다.

```python
import time, neopixel
from machine import Pin

PIN = 16
NUM_PIXELS = 64
np = neopixel.NeoPixel(Pin(PIN, Pin.OUT), NUM_PIXELS)

def wheel(pos):
    if pos < 85:
        return (int(pos * 3), int(255 - pos * 3), 0)
    elif pos < 170:
        pos -= 85
        return (int(255 - pos * 3), 0, int(pos * 3))
    else:
        pos -= 170
        return (0, int(pos * 3), int(255 - pos * 3))

def rainbow_cycle(wait=0.05):
    while True:
        for j in range(256):
            for i in range(NUM_PIXELS):
                np[i] = wheel((i * 256 // NUM_PIXELS + j) & 255)
            np.write()
            time.sleep(wait)

def main():
    try:
        rainbow_cycle(0.05)
    except KeyboardInterrupt:
        np.fill((0,0,0))
        np.write()

if __name__ == "__main__":
    main()
```

## 좌표 지정 제어 

이번에는 원하는 좌표(x, y) 의 픽셀 색상을 지정하는 형태로 작성해 보겠습니다. 

```python
from machine import Pin
from rp2 import PIO, StateMachine, asm_pio
import time

@asm_pio(
    sideset_init=PIO.OUT_LOW,
    out_shiftdir=PIO.SHIFT_LEFT,
    autopull=True,
    pull_thresh=24
)
def ws2812():
    T1 = 2
    T2 = 5
    T3 = 3
    wrap_target()
    label("bitloop")
    out(x, 1)               .side(0) [T3 - 1]
    jmp(not_x, "do_zero")   .side(1) [T1 - 1]
    jmp("bitloop")          .side(1) [T2 - 1]
    label("do_zero")
    nop()                   .side(0) [T2 - 1]
    wrap()

class WS2812MatrixPIO:
    def __init__(self, pin, width=8, height=8, sm_id=0, freq=8_000_000):
        self.width, self.height = width, height
        self.buf = bytearray(width * height * 3)
        self.sm = StateMachine(sm_id, ws2812, freq=freq, sideset_base=Pin(pin))
        self.sm.active(1)

    def _idx(self, x, y):
        return (y * self.width + x) * 3

    def __setitem__(self, xy, rgb):
        x, y = xy
        r, g, b = rgb
        i = self._idx(x, y)
        self.buf[i + 0] = g & 0xFF
        self.buf[i + 1] = r & 0xFF
        self.buf[i + 2] = b & 0xFF

    def clear(self):
        for i in range(len(self.buf)):
            self.buf[i] = 0

    def show(self):
        mv = memoryview(self.buf)
        for i in range(0, len(mv), 3):
            v = (mv[i] << 16) | (mv[i + 1] << 8) | mv[i + 2]
            self.sm.put(v, 8)
        time.sleep_us(300)

matrix = WS2812MatrixPIO(pin=16, width=8, height=8)
matrix.clear()
matrix[3, 4] = (255, 0, 0)
matrix[4, 4] = (0, 255, 0)
matrix[5, 4] = (0, 0, 255)
matrix.show()
```

## 숫자 출력 

이번에는 8x8 공간에 3x5 크기의 숫자를 출력하도록 작성하면 다음처럼 제어할 수 있습니다. 

```python
from machine import Pin
from rp2 import PIO, StateMachine, asm_pio
import time

@asm_pio(
    sideset_init=PIO.OUT_LOW,
    out_shiftdir=PIO.SHIFT_LEFT,
    autopull=True,
    pull_thresh=24
)
def ws2812():
    T1 = 2
    T2 = 5
    T3 = 3
    wrap_target()
    label("bitloop")
    out(x, 1)               .side(0) [T3 - 1]
    jmp(not_x, "do_zero")   .side(1) [T1 - 1]
    jmp("bitloop")          .side(1) [T2 - 1]
    label("do_zero")
    nop()                   .side(0) [T2 - 1]
    wrap()

class WS2812MatrixPIO:
    def __init__(self, pin, width=8, height=8, sm_id=0, freq=8_000_000):
        self.width, self.height = width, height
        self.buf = bytearray(width * height * 3)
        self.sm = StateMachine(sm_id, ws2812, freq=freq, sideset_base=Pin(pin))
        self.sm.active(1)

    def _idx(self, x, y):
        return (y * self.width + x) * 3

    def __setitem__(self, xy, rgb):
        x, y = xy
        r, g, b = rgb
        i = self._idx(x, y)
        self.buf[i + 0] = g & 0xFF
        self.buf[i + 1] = r & 0xFF
        self.buf[i + 2] = b & 0xFF

    def clear(self):
        for i in range(len(self.buf)):
            self.buf[i] = 0

    def show(self):
        mv = memoryview(self.buf)
        for i in range(0, len(mv), 3):
            v = (mv[i] << 16) | (mv[i + 1] << 8) | mv[i + 2]
            self.sm.put(v, 8)
        time.sleep_us(300)

DIGITS_3x5 = {
    '0': ["111","101","101","101","111",],
    '1': ["010","110","010","010","111",],
    '2': ["111","001","111","100","111",],
    '3': ["111","001","111","001","111",],
    '4': ["101","101","111","001","001",],
    '5': ["111","100","111","001","111",],
    '6': ["111","100","111","101","111",],
    '7': ["111","001","010","010","010",],
    '8': ["111","101","111","101","111",],
    '9': ["111","101","111","001","111",]
}

def clamp_xy(matrix, x, y):
    return 0 <= x < matrix.width and 0 <= y < matrix.height

def clear_rect(matrix, x, y, w, h):
    for yy in range(y, y+h):
        for xx in range(x, x+w):
            if clamp_xy(matrix, xx, yy):
                matrix[xx, yy] = (0,0,0)

def draw_digit(matrix, ch, x, y, color=(255,255,255), bg=None):
    pat = DIGITS_3x5.get(ch)
    if not pat:
        return
    for row in range(5):
        line = pat[row]
        for col in range(3):
            on = (line[col] == '1')
            cx, cy = x + col, y + row
            if clamp_xy(matrix, cx, cy):
                if on:
                    matrix[cx, cy] = color
                elif bg is not None:
                    matrix[cx, cy] = bg

def draw_number(matrix, n, color=(255,255,255), bg=None, center=True, x=0, y=1, spacing=1):
    s = str(max(0, min(99, int(n))))
    total_w = len(s) * 3 + (len(s)-1) * spacing
    if center:
        x = (matrix.width - total_w) // 2
    if bg is not None:
        clear_rect(matrix, x, y, total_w, 5)
    cx = x
    for ch in s:
        draw_digit(matrix, ch, cx, y, color=color, bg=bg)
        cx += 3 + spacing

def blink_number(matrix, n, color=(255,255,255), bg=(0,0,0), times=3, on_ms=200, off_ms=120):
    for _ in range(times):
        draw_number(matrix, n, color=color, bg=bg, center=True)
        matrix.show()
        time.sleep_ms(on_ms)
        clear_rect(matrix, 0, 0, matrix.width, matrix.height)
        matrix.show()
        time.sleep_ms(off_ms)

def countdown(matrix, start=9, color=(255,160,32), bg=(0,0,0), step_ms=700):
    for v in range(start, -1, -1):
        draw_number(matrix, v, color=color, bg=bg, center=True)
        matrix.show()
        time.sleep_ms(step_ms)
    blink_number(matrix, 0, color=color, bg=bg, times=2, on_ms=150, off_ms=100)

matrix = WS2812MatrixPIO(pin=16, width=8, height=8)
matrix.clear()
draw_number(matrix, 7, color=(0,255,80), bg=(0,0,0), center=True, y=1)
matrix.show()
time.sleep(2)

matrix.clear()
draw_number(matrix, 42, color=(80,180,255), bg=(0,0,0), center=True, y=1)
matrix.show()
time.sleep(2)

matrix.clear()
countdown(matrix, start=9, color=(255,120,40), bg=(0,0,0), step_ms=500)

matrix.clear()
matrix.show()
```

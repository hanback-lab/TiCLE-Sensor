# Push Switch 
푸시 스위치는 **순간적으로 회로를 연결하거나 끊는 장치**입니다.  
보통 한쪽 단자는 **입력 핀(GPIO)** 에, 다른 한쪽 단자는 **GND**에 연결합니다.  

- **스위치가 눌리지 않은 상태:**  
  내부 풀업 저항에 의해 입력 핀은 HIGH(1)
- **스위치가 눌린 상태:**  
  회로가 GND에 연결되어 LOW(0)

즉, 스위치 입력 값은 다음과 같이 해석됩니다:

| 스위치 상태 | 입력 값 | 설명 |
|:--|:--:|:--|
| 눌림 | 0 | 회로가 닫힘 (GND 연결) |
| 해제 | 1 | 회로가 열림 (Pull-up 유지) |

## Push Switch 연결 구성 

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| GP17 | SW1 | Push Switch 1 |
| GP18 | SW2 | Push Switch 2 |

![Push Switch Connection](res/push%20switch%20connection.png)

## Push Switch 상태 읽기
다음 예제는 **SW1, SW2의 상태를 주기적으로 읽어 콘솔에 출력**하는 기본 코드입니다.

```python
from machine import Pin
import utime

PIN_SW1   = 17
PIN_SW2   = 18

def main():
    sw1 = Pin(PIN_SW1,   Pin.IN, Pin.PULL_UP)
    sw2 = Pin(PIN_SW2,   Pin.IN, Pin.PULL_UP)
    try:
        while True:
            print(f"SW1:{sw1.value()}  SW2:{sw2.value()}")
            utime.sleep_ms(500)
    except KeyboardInterrupt:
        print("End.")

if __name__ == "__main__":
    main()
```

이렇게 반복하여 계속하여 핀의 상태를 체크하는 형태를 폴링(Polling)이라 합니다. 폴링방식은 지속적으로 핀의 상태를 감지하는대신 다른 작업에 지연이 발생할 수 있습니다. 

## IRQ(Interrupt Request) 등록을 통한 이벤트 감지
폴링 방식보다 조금더 효율적으로 상태변화를 체크하고 싶다면 인터럽트(IRQ) 를 활용하는 방식을 활용하는것이 좋습니다. 

인터럽트는 등록한 핀의 상태가 정의된 트리거에 따라 상태가 변화하면 CPU에 신호를 보내고 등록된 콜백 함수를 즉시 실행하는 형태로, 폴링방식과 다르게 지속적으로 상태를 감지하지 않아도 상태변화와 작성한 다른 코드를 병행하여 실행할 수 있는 상태를 만들 수 있습니다. 다만, 신호 변화에 따른 호출로 인해 노이즈에 오동작하는경우가 발생할 수 있습니다.  

### 폴링과 인터럽트 비교 
폴링방식과 인터럽트 방식을 비교하면 다음과 같이 정리할 수 있습니다. 

| 구분 | 폴링(Polling) | 인터럽트(Interrupt) |
|:--|:--|:--|
| 처리 방식 | 루프에서 주기적으로 검사 | 하드웨어 신호로 즉시 호출 |
| 반응 속도 | 느림 (주기 의존) | 빠름 (즉시 처리) |
| CPU 효율 | 낮음 | 높음 |
| 코드 복잡도 | 단순 | 상대적으로 복잡 |

마이크로 파이썬에서 인터럽트설정하기 위해서는 Pin 클래스의 irq(trigger, handler) 메소드를 활용합니다. 

- Pin.irq(trigger, handler) : 인터럽트 등록
    - trigger : 어떤 신호에 반응할지 설정, Pin.IRQ_RISING, Pin.IRQ_FALLING
    - handler : 인터럽트 발생 시 호출할 콜백 함수 

다음은 인터럽트 방식을 활용하여 푸쉬 스위치의 상태를 출력하는 코드입니다. 

```python
from machine import Pin
import utime

PIN_SW1 = 17
PIN_SW2 = 18

def callback_sw1(pin):
    print("SW1 Pushed")

def callback_sw2(pin):
    print("SW2 Pushed")

def main():
    sw1 = Pin(PIN_SW1, Pin.IN, Pin.PULL_UP)
    sw2 = Pin(PIN_SW2, Pin.IN, Pin.PULL_UP)

    sw1.irq(trigger=Pin.IRQ_FALLING, handler=callback_sw1)
    sw2.irq(trigger=Pin.IRQ_FALLING, handler=callback_sw2)

    try:
        while True:
            utime.sleep(1)
    except KeyboardInterrupt:
        print("End")

if __name__ == "__main__":
    main()
```

## 디바운싱 
스위치는 **기계적인 접점(Contact)** 으로 이루어져 있기 때문에, 눌릴 때 접점이 "탁!" 하고 바로 붙지 않고 수 ms 동안 튕기며 접촉과 단락을 반복합니다.

이로 인해 실제로는 한 번 눌렀음에도 불구하고 짧은 시간 안에 여러 번 눌린 것처럼 감지될 수 있습니다. 이를 **채터링(Chattering)** 이라고 하며, 이를 제거하는 과정을 **디바운싱(Debouncing)** 이라 부릅니다.

하드웨어 적으로는 스위치에 RC 필터(저항 + 콘덴서)를 추가하여 노이즈를 완화 하는 방식이 있으며, 소프트웨어적으로는 입력이 감지된 후 일정시간동안 추가 입력을 무시하는 방식을 통해 보완할 수 있습니다. 

```python
from machine import Pin
import utime

PIN_SW1 = 17
PIN_SW2 = 18
DEBOUNCE_MS = 100

last_time_sw1 = 0
last_time_sw2 = 0

def callback_sw1(pin):
    global last_time_sw1
    now = utime.ticks_ms()
    if utime.ticks_diff(now, last_time_sw1) > DEBOUNCE_MS:
        print("SW1 Pushed")
        last_time_sw1 = now

def callback_sw2(pin):
    global last_time_sw2
    now = utime.ticks_ms()
    if utime.ticks_diff(now, last_time_sw2) > DEBOUNCE_MS:
        print("SW2 Pushed")
        last_time_sw2 = now

def main():
    sw1 = Pin(PIN_SW1, Pin.IN, Pin.PULL_UP)
    sw2 = Pin(PIN_SW2, Pin.IN, Pin.PULL_UP)

    sw1.irq(trigger=Pin.IRQ_FALLING, handler=callback_sw1)
    sw2.irq(trigger=Pin.IRQ_FALLING, handler=callback_sw2)

    try:
        while True:
            utime.sleep(1)
    except KeyboardInterrupt:
        print("End")

if __name__ == "__main__":
    main()
```

# TextLCD
TextLCD는 문자 기반의 액정 디스플레이(Liquid Crystal Display)로, 일반적으로 **16x2** 혹은 **20x2** 혹은 **20x4** 형태로 많이 사용됩니다.  
각 자리에는 영문자, 숫자, 기호 등을 표시할 수 있으며, 내부적으로 **HD44780** 호환 컨트롤러를 사용합니다.

## TextLCD 제어 방식 
TextLCD는 기본적으로 **HD44780 컨트롤러**를 기반으로 하며,  
이를 제어하는 방식에는 크게 **병렬(Parallel)** 방식과 **I2C(Serial)** 방식이 있습니다.  
두 방식은 내부 명령어 체계는 동일하지만, **MCU와의 연결 방법과 데이터 전송 방식**이 다릅니다.

### 병렬 방식(GPIO 직접 제어)
HD44780 LCD 모듈은 데이터 전송을 위해 다음과 같은 신호선을 사용합니다.

| 구분 | 신호명 | 설명 |
|------|--------|------|
| 제어선 | RS | Register Select: 0=명령, 1=데이터 |
| 제어선 | RW | Read/Write: 0=쓰기, 1=읽기 (일반적으로 GND에 고정하여 Write 전용) |
| 제어선 | EN | Enable: 데이터 래치 시 펄스(High→Low) 신호 |
| 데이터선 | D0~D7 | 데이터 비트 (8비트 모드 시 전부 사용, 4비트 모드 시 D4~D7만 사용) |

데이터선을 사용하는 방식에 따라 다음과 같이 2가지 모드로 구분됩니다.

| 모드 | 제어핀 수 | 데이터핀 수 | 총 연결선 수 | 비고 |
|------|------------|--------------|---------------|------|
| 8비트 모드 | 3 (RS, RW, EN) | 8 (D0~D7) | **11핀** | 빠르지만 GPIO 많이 사용 |
| 4비트 모드 | 3 (RS, RW, EN) | 4 (D4~D7) | **7핀** | 속도 약간 느림, 하지만 핀 절약 |

8비트 모드일때는 데이터를 한번에 전송하는 방식이며, 4비트 모드일때는 데이터를 상위 4비트와 하위 4비트 순서로 두번 전송하는 방식입니다. 

병렬방식을 활용하면 GPIO를 직접 제어하기 때문에 I2C 를 활용하는 방식보다 속도가 빠르며, 별도의 확장 모듈없이 하드웨어 구성이 가능합니다. 다만, 제어를 위한 구성단계에서 연결해야할 GPIO의 수가 많으며 배선의 복잡도가 올라갑니다. 

### I2C 방식 
I2C 방식은 I/O 확장 칩을 내장하여 제어하는 방식입니다. MCU와 연결은 전원(VCC, GND)와 I2C 라인(SDA, SCL)을 통해 I/O 확장 칩에 데이터를 전송합니다. LCD에는 4비트 모드로 제어합니다. 

병렬방식에 비해 배선이 간단하고, I2C 버스에 다른 여러개의 장치를 연결하여 활용할 수 있는 장점을 가집니다. 단, 병렬 방식에 비해 전송속도가 느리며, 같은 I2C 버스에 다른 장치가 연결되는 경우에는 장치 주소가 중복되지 않도록 구성해야 합니다. 

## TextLCD 제어 명령 

| 명령어 이름 | 16진수(기본값) | 비트 구조 (D7~D0) | 주요 옵션 비트 | 설명 | 비고 |
|--------------|----------------|------------------|----------------|------|------|
| **Clear Display** | `0x01` | `0000 0001` | - | 화면의 모든 문자를 지우고 커서를 (0,0)으로 이동합니다. | 실행 시간 약 1.52ms 필요 |
| **Return Home** | `0x02` | `0000 0010` | - | 커서를 홈 위치(0,0)로 복귀시키며, 디스플레이 시프트 상태를 초기화합니다. | 약 1.52ms 필요 |
| **Entry Mode Set** | `0x04 + I/D + S` | `0000 01IS` | I/D=1 → 오른쪽 이동<br>I/D=0 → 왼쪽 이동<br>S=1 → 디스플레이 시프트 | 문자를 출력할 때 커서/디스플레이 이동 방향을 설정합니다. | 기본값: I/D=1, S=0 |
| **Display Control** | `0x08 + D + C + B` | `0000 1DCB` | D=1 → 디스플레이 ON<br>C=1 → 커서 ON<br>B=1 → 커서 점멸(Blink) | 화면 표시, 커서 표시, 깜박임 등을 제어합니다. | 일반적으로 `0x0C`(ON, 커서X, 블링크X) |
| **Cursor / Display Shift** | `0x10 + S/C + R/L` | `0001 SCRL` | S/C=1 → 디스플레이 이동<br>S/C=0 → 커서 이동<br>R/L=1 → 오른쪽 이동<br>R/L=0 → 왼쪽 이동 | 커서 또는 디스플레이를 한 칸씩 이동시킵니다. | 애니메이션 효과 등에 활용 |
| **Function Set** | `0x20 + DL + N + F` | `001DNFxx` | DL=1 → 8비트 모드<br>DL=0 → 4비트 모드<br>N=1 → 2라인<br>F=1 → 5x10 폰트 | LCD의 데이터 길이, 라인 수, 폰트 크기를 설정합니다. | 4비트·2라인·5x8도트: `0x28` |
| **Set CGRAM Address** | `0x40 + addr` | `01xxxxxx` | addr(6bit) | 사용자 정의 문자 저장 영역 주소 지정 | `create_char()`에서 사용 |
| **Set DDRAM Address** | `0x80 + addr` | `1xxxxxxx` | addr(7bit) | 커서 위치를 지정합니다. (문자 출력 위치 설정) | 1행=0x00, 2행=0x40, 3행=0x14, 4행=0x54 |
| **Read Busy Flag & Address** | `0xBF` (Read mode) | - | BF=Busy Flag | 내부 명령 처리 중인지 확인합니다. | I2C 모듈에서는 사용 어려움 |
| **Write Data to RAM** | `0x40` (RS=1) | - | - | 현재 주소에 문자 데이터를 씁니다. | 문자 출력 시 자동 증가 |
| **Read Data from RAM** | `0x41` (RS=1, RW=1) | - | - | 현재 주소의 문자 데이터를 읽습니다. | 잘 사용되지 않음 |


## TextLCD 연결 구성 
이번 실습에서는 **PCF8574 I/O 익스팬더**가 부착된 **I2C 타입 TextLCD**를 사용합니다.  
이 방식은 기존의 병렬(8핀) 연결과 달리 **2개의 I2C 신호선(SDA, SCL)** 만으로 LCD를 제어할 수 있기 때문에, **Raspberry Pi Pico**나 **MicroPython 보드**에서 매우 효율적으로 사용됩니다.

| 항목 | 설명 |
|------|------|
| 통신 방식 | I2C (SDA, SCL) |
| 주소 | 기본 0x27 (모듈에 따라 0x3F 등 다를 수 있음) |
| 전원 | 5V 또는 3.3V (보드에 따라 다름) |
| 연결 핀 | SDA → GP0, SCL → GP1 |
| 표시 문자 수 | 20자 × 4줄 |
| 백라이트 | ON/OFF 제어 가능 |

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| GP0 | SDA | I2C 데이터 |
| GP1 | SCL | I2C 클록 |

![TextLCD Connection](res/textlcd%20connection.png)

## TextLCD 제어 코드 
다음은 MicroPython 환경에서 **I2C 기반 TextLCD를 제어하는 예제 코드**입니다.  
`TextLCD` 클래스는 LCD 초기화, 문자열 표시, 커서 이동, 백라이트 제어 등 다양한 기능을 포함하고 있습니다.

```python
from machine import I2C, Pin
import utime

class TextLCD:
    CLEARDISPLAY   = 0x01
    RETURNHOME     = 0x02
    ENTRYMODESET   = 0x04
    DISPLAYCONTROL = 0x08
    CURSORSHIFT    = 0x10
    FUNCTIONSET    = 0x20
    SETCGRAMADDR   = 0x40
    SETDDRAMADDR   = 0x80

    ENTRYRIGHT          = 0x00
    ENTRYLEFT           = 0x02
    ENTRYSHIFTINCREMENT = 0x01
    ENTRYSHIFTDECREMENT = 0x00

    DISPLAYON  = 0x04
    DISPLAYOFF = 0x00
    CURSORON   = 0x02
    CURSOROFF  = 0x00
    BLINKON    = 0x01
    BLINKOFF   = 0x00

    DISPLAYMOVE = 0x08
    CURSORMOVE  = 0x00
    MOVERIGHT   = 0x04
    MOVELEFT    = 0x00

    _8BITMODE = 0x10
    _4BITMODE = 0x00
    _2LINE    = 0x08
    _1LINE    = 0x00
    _5x10DOTS = 0x04
    _5x8DOTS  = 0x00

    def __init__(self, i2c: I2C, addr=0x27, cols=20, rows=4, backlight=True):
        self.i2c = i2c
        self.addr = addr
        self.cols = cols
        self.rows = rows
        self.backlight = bool(backlight)
        self.map = dict(RS=0, RW=1, EN=2, BL=3, D4=4, D5=5, D6=6, D7=7)

        self.display_function = self._4BITMODE | (self._2LINE if rows > 1 else self._1LINE) | self._5x8DOTS
        self.display_control = self.DISPLAYON | self.CURSOROFF | self.BLINKOFF
        self.display_mode = self.ENTRYLEFT | self.ENTRYSHIFTDECREMENT
        self._row_offsets = [0x00, 0x40, 0x14, 0x54]

        self._out_cache = 0x00
        self._write_out(0x00)
        self._init_lcd()

    def _bit(self, name): 
        return 1 << self.map[name]

    def _compose_out(self, d7,d6,d5,d4,en,rw,rs,bl):
        v = 0
        if 'D7' in self.map and d7: v |= self._bit('D7')
        if 'D6' in self.map and d6: v |= self._bit('D6')
        if 'D5' in self.map and d5: v |= self._bit('D5')
        if 'D4' in self.map and d4: v |= self._bit('D4')
        if en: v |= self._bit('EN')
        if 'RW' in self.map and rw: v |= self._bit('RW')
        if rs: v |= self._bit('RS')
        if self.backlight and 'BL' in self.map and bl: v |= self._bit('BL')
        return v

    def _write_out(self, value):
        self._out_cache = value
        self.i2c.writeto(self.addr, bytes([value]))

    def _pulse_enable(self, value):
        self._write_out(value | self._bit('EN'))
        utime.sleep_us(1)
        self._write_out(value & ~self._bit('EN'))
        utime.sleep_us(50)

    def _write4(self, nibble, rs):
        d4 = (nibble >> 0) & 1
        d5 = (nibble >> 1) & 1
        d6 = (nibble >> 2) & 1
        d7 = (nibble >> 3) & 1
        base = self._compose_out(d7,d6,d5,d4,0,0,rs,1)
        self._pulse_enable(base)

    def _send(self, value, rs):
        self._write4((value >> 4) & 0x0F, rs)
        self._write4(value & 0x0F, rs)

    def _command(self, cmd): 
        self._send(cmd, rs=0)
        
    def _write_char(self, ch): 
        self._send(ch, rs=1)

    def _init_lcd(self):
        utime.sleep_ms(50)
        for _ in range(2):
            self._write4(0x03, rs=0); 
            utime.sleep_ms(5)
        self._write4(0x03, rs=0); 
        utime.sleep_us(150)
        self._write4(0x02, rs=0)

        self._command(self.FUNCTIONSET | self.display_function)
        self.display_off()
        self.clear()
        self._command(self.ENTRYMODESET | self.display_mode)
        self.display_on()

    def clear(self):
        self._command(self.CLEARDISPLAY)
        utime.sleep_ms(2)

    def home(self):
        self._command(self.RETURNHOME)
        utime.sleep_ms(2)

    def display_on(self):
        self.display_control |= self.DISPLAYON
        self._command(self.DISPLAYCONTROL | self.display_control)

    def display_off(self):
        self.display_control &= ~self.DISPLAYON
        self._command(self.DISPLAYCONTROL | self.display_control)

    def cursor(self, enable=True):
        if enable: 
            self.display_control |= self.CURSORON
        else: 
            self.display_control &= ~self.CURSORON
        self._command(self.DISPLAYCONTROL | self.display_control)

    def blink(self, enable=True):
        if enable: 
            self.display_control |= self.BLINKON
        else: 
            self.display_control &= ~self.BLINKON
        self._command(self.DISPLAYCONTROL | self.display_control)

    def backlight_on(self, enable=True):
        self.backlight = bool(enable)
        v = self._out_cache
        if 'BL' in self.map:
            if self.backlight: v |= self._bit('BL')
            else: v &= ~self._bit('BL')
        self._write_out(v)

    def set_cursor(self, col, row):
        row = max(0, min(row, self.rows - 1))
        col = max(0, min(col, self.cols - 1))
        self._command(self.SETDDRAMADDR | (self._row_offsets[row] + col))

    def write(self, text):
        if isinstance(text, bytes):
            for b in text: 
                self._write_char(b)
            return
        for c in str(text):
            self._write_char(ord(c))

    def _pad_right(self, s, width):
        s = "" if s is None else str(s)
        n = len(s)
        return s[:width] if n >= width else (s + (" " * (width - n)))

    def write_line(self, row, text):
        self.set_cursor(0, row)
        self.write(self._pad_right(text, self.cols))

    def clear_line(self, row):
        self.write_line(row, "")

    def write_center(self, row, text):
        s = "" if text is None else str(text)
        s = s[:self.cols]
        pad = max(0, self.cols - len(s))
        left = pad // 2
        self.set_cursor(0, row)
        self.write((" " * left) + s + (" " * (self.cols - left - len(s))))

    def create_char(self, location, charmap):
        location &= 0x7
        self._command(self.SETCGRAMADDR | (location << 3))
        for i in range(8):
            self._write_char(charmap[i] & 0x1F)
        self.home()

def main():
    i2c = I2C(0, sda=Pin(0), scl=Pin(1), freq=400000)
    lcd = TextLCD(i2c, addr=0x27, cols=20, rows=4, backlight=True)

    lcd.clear()
    lcd.write_line(0, "Hello, TiCLE Sensor!")
    lcd.write_center(1, "20x4 LCD")
    lcd.write_center(2, "Initialize OK")
    for k in range(20):
        lcd.set_cursor(k, 3)
        lcd.write("#")

if __name__ == "__main__":
    main()
```

<details>
<summary>심화 학습</summary>

## TextLCD 클래스 기능 추가 
**공개 API**를 설계·추가하여 고수준 메서드만으로 시프트를 제어하겠습니다. 
즉, 사용자 코드는 `shift_cursor()`, `shift_display()` 같은 **명시적인 메서드**만 호출하고, 내부의 레지스터 조합은 클래스가 책임지도록 설계를 개선합니다.

### 공개 API 설계 목표
- `_command()`/`_send()` 같은 **저수준(private)** 메서드는 숨깁니다.
- **의도 중심 메서드** 제공:
  - `shift_cursor(right=True, steps=1)`
  - `shift_display(right=True, steps=1)`
  - `type_text(text, delay_ms=0)`  (타자기 효과)
  - `scroll_line(row, text, speed_ms=200, cycles=1)` (마키 효과)
- 기존 공개 메서드(`display_on/off`, `cursor`, `blink`, `backlight_on`, `set_cursor`, `write_line`)와 **일관된 인터페이스** 유지

---

### TextLCD 클래스에 추가할 공개 메서드 
아래 코드는 **추가/변경된 부분만** 발췌했습니다. 전체 클래스에 그대로 붙여 넣으셔도 동작합니다. (상단의 상수 정의는 이미 클래스에 포함되어 있으니, 그대로 재사용하시면 됩니다.)

```python
    def shift_cursor(self, right: bool = True, steps: int = 1):
        steps = max(1, int(steps))
        cmd = self.CURSORSHIFT | self.CURSORMOVE | (self.MOVERIGHT if right else self.MOVELEFT)
        for _ in range(steps):
            self._command(cmd)

    def shift_display(self, right: bool = True, steps: int = 1):
        steps = max(1, int(steps))
        cmd = self.CURSORSHIFT | self.DISPLAYMOVE | (self.MOVERIGHT if right else self.MOVELEFT)
        for _ in range(steps):
            self._command(cmd)

    def type_text(self, text: str, delay_ms: int = 0):
        for c in str(text):
            self._write_char(ord(c))
            if delay_ms > 0:
                utime.sleep_ms(delay_ms)

    def scroll_line(self, row: int, text: str, speed_ms: int = 200, cycles: int = 1, direction: str = "left"):
        row = max(0, min(row, self.rows - 1))
        self.write_line(row, text[:self.cols])
        right = (direction.lower() == "right")
        steps = max(1, self.cols)
        for _ in range(max(1, cycles)):
            for _ in range(steps):
                self.shift_display(right=right, steps=1)
                utime.sleep_ms(max(10, speed_ms))
```

수정된 TextLCD 클래스를 활용한 커서 시프트 테스트 코드는 다음과 같습니다. 
```python 
def main():
    i2c = I2C(0, sda=Pin(0), scl=Pin(1), freq=400000)
    lcd = TextLCD(i2c, addr=0x27, cols=20, rows=4, backlight=True)
    lcd.clear()
    lcd.write_line(0, "Cursor Shift Demo")
    lcd.set_cursor(0, 2)
    lcd.type_text("ABCDE", delay_ms=0)

    lcd.shift_cursor(right=False, steps=5)
    lcd.type_text("abcde", delay_ms=0)
```

디스플레이 시프트 테스트 코드는 다음과 같습니다. 
```python
def main():
    i2c = I2C(0, sda=Pin(0), scl=Pin(1), freq=400000)
    lcd = TextLCD(i2c, addr=0x27, cols=20, rows=4, backlight=True)
    lcd.clear()
    lcd.write_line(0, "Display Shift Demo")
    lcd.write_line(1, "Welcome to TiCLE!")
    utime.sleep_ms(500)

    lcd.shift_display(right=False, steps=lcd.cols)
    utime.sleep_ms(300)

    lcd.shift_display(right=True, steps=lcd.cols)
```
</details>
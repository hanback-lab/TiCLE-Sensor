# 비동기 제어 
IoT 시스템에서는 여러 센서로부터 데이터를 읽고, 그 값을 기반으로 액추에이터(모터, 릴레이, LED 등) 를 제어합니다.
이 과정에서 모든 작업을 순차적으로(동기 방식) 처리하면 하나의 센서가 느리게 응답할 때 전체 시스템이 지연될 수 있습니다.

이를 해결하기 위해, 비동기 제어(Asynchronous Control) 기법을 사용하면 여러 센서나 장치를 동시에 처리할 수 있습니다.
이는 RT/NRT 분리 스케줄링을 이해하기 위한 기본 개념이기도 합니다.

## 동기방식과 비동기 방식의 차이 
예를 들어 A,B,C 라는 작업을 수행하는데, 작업에 수행되는 시간이 A는 5초, B는 10초, C 는 15초 가 걸린다고 가정해보겠습니다. 이를 순차적으로 처리하면 총 30초가 소요됩니다. 하지만 작업을 순차적으로 처리하는 것이 아닌 비동기 방식으로 처리하면 약 15초 만에 처리가 가능합니다. 

![sync & async](res/sync&async.png)

동기 방식과 비동기 방식을 요약해서 정리하면 다음과 같이 정리할 수 있습니다. 

| 항목 | 동기 방식 | 비동기 방식 |
|:-------|:------|:------|
| 실행 방식 | 순차 실행 | 동시 실행 | 
| 총 작업 시간 | 모든 작업 시간 누적 | 가장 긴 작업 시간에 수렴 | 
| 사용 예시 | DB 트랜잭션, 시리얼 처리 등 | 센서 데이터 수집, 네트워크 요청 등 | 

### 동기 방식 예시 
```python
import time

def task_sync(name, duration):
    print(f"{name} 시작")
    time.sleep(duration)
    print(f"{name} 완료")

def run_sync_tasks():
    start = time.time()
    task_sync("A", 5)
    task_sync("B", 10)
    task_sync("C", 15)
    end = time.time()
    print(f"총 소요 시간: {end - start:.2f}초")

if __name__ == "__main__":
    run_sync_tasks()
```

### 비동기 방식 예시 
```python
import asyncio
import time

async def task_async(name, duration):
    print(f"{name} 시작")
    await asyncio.sleep(duration)
    print(f"{name} 완료")

async def run_async_tasks():
    start = time.time()
    await asyncio.gather(
        task_async("A", 5),
        task_async("B", 10),
        task_async("C", 15)
    )
    end = time.time()
    print(f"총 소요 시간: {end - start:.2f}초")

if __name__ == "__main__":
    asyncio.run(run_async_tasks())
```

## asyncio 
asyncio는 파이썬에서 비동기 I/O 처리하기 위한 표준 라이브러리 모듈입니다. 복잡한 스레드나 프로세스 없이도, 단일 스레드 내에서 수많은 네트워크 요청, 타이머 웹소켓 과 같은 작업들을 효율적으로 동시 실행할 수 있게 해줍니다. 

### asyncio 작동 원리 
asyncio는 이벤트 루프 기반으로 동작합니다. 하나의 이벤트 루프가 있으며, async def로 정의된 코루틴(coroutine) 들이 등록됩니다. await 키워드를 통해 작업중인 비동기 작업을 일시 중단하고 대기중인 다른 작업을 수행할 수 있게 합니다. 

### 주요 구성 요소 

- async def : 비동기 함수 정의, 코루틴 객체를 생성 
- await : 코루틴 실행 중 일시 중단, 호출 시 다른 작업에 CPU 양보 
- asyncio.run() : 이벤트 루프 생성 및 코루틴 실행 
- asyncio.create_task() : 여러 코루틴을 통시에 실행하는 태스크 
- asyncio.sleep() : 비동기 타이머, 논블로킹(non-blocking) 방식으로 실행
    - time.sleep() 을 사용하면 블로킹 상태가 되어 비동기 처리와는 맞지 않음! 

## 비동기 센서 데이터 수집 
### 온/습도, 조도 데이터 수집 1 (동기 방식)
비동기(uasyncio) 기반으로 mmWave 프레임 수집, LCD 갱신, 로깅, 상태 LED를 동시에 수행합니다.

| 기능 | 센서/모듈 | Pico2 W 핀 | 비고 |
| --- | --- | --- | --- |
| HMMD mmWave UART | TX/RX | `UART1` → TX=GP8, RX=GP9  | 3.3V 레벨 |
| TextLCD(PCF8574) | I²C | `I2C0` → SDA=GP0, SCL=GP1 | 주소 0x27/0x3F |
| 상태 LED | LED | GP15 | 내장 LED 사용 시 보드 LED 핀에 맞게 변경 |
| (선택) NeoPixel 8LED | DIN | GP16 | 5V 레벨 |

```python
import uasyncio as asyncio
from machine import Pin, I2C, UART
import time

UART_ID = 1
PIN_TX  = 8
PIN_RX  = 9
BAUD    = 115200
uart_mm = UART(UART_ID, baudrate=BAUD, tx=Pin(PIN_TX), rx=Pin(PIN_RX), timeout=20)

I2C_ID  = 0
SDA_PIN = 0
SCL_PIN = 1
i2c = I2C(I2C_ID, sda=Pin(SDA_PIN), scl=Pin(SCL_PIN), freq=400_000)
LCD_ADDR_CAND = [0x27, 0x3F]  # 자동 탐지 순서

LED_PIN = 15
led = Pin(LED_PIN, Pin.OUT, value=0)

class LCDAdapter:
    def __init__(self, i2c, addr=None, cols=20, rows=4):
        self.cols, self.rows = cols, rows
        found = i2c.scan()
        if addr is None:
            for a in LCD_ADDR_CAND:
                if a in found:
                    addr = a
                    break
        if addr not in found:
            raise RuntimeError("I2C LCD(PCF8574) 미검출: 배선/전원/주소 확인")

        self.lcd = None
        self.mode = None

        for ctor in (
            lambda: TextLCD(i2c, addr=addr),    # TextLCD(i2c, addr=..)
            lambda: TextLCD(i2c),               # TextLCD(i2c)
            lambda: TextLCD(addr),              # TextLCD(addr)
            lambda: TextLCD(),                  # TextLCD()
        ):
            try:
                obj = ctor()
                if hasattr(obj, "move_to") and hasattr(obj, "putstr"):
                    self.lcd = obj
                    self.mode = "move_put"
                    break
                if hasattr(obj, "write_line"):
                    self.lcd = obj
                    self.mode = "write_line"
                    break
                if hasattr(obj, "print_line"):
                    self.lcd = obj
                    self.mode = "print_line"
                    break
            except Exception:
                pass

        if self.lcd is None:
            self.mode = "console"
            print(f"[LCD(Console)] addr=0x{addr:02X}, cols={cols}, rows={rows}")
        else:
            print(f"[LCD] addr=0x{addr:02X}, mode={self.mode}, cols={cols}, rows={rows}")

        try:
            if hasattr(self.lcd, "clear"):
                self.lcd.clear()
        except Exception:
            pass

    def show(self, lines):
        if self.mode == "move_put":
            try:
                if hasattr(self.lcd, "clear"):
                    self.lcd.clear()
                for r in range(self.rows):
                    text = lines[r] if r < len(lines) else ""
                    self.lcd.move_to(0, r)
                    self.lcd.putstr(text[:self.cols])
            except Exception as e:
                print("[LCD(move_put) ERROR]", e)

        elif self.mode == "write_line":
            try:
                if hasattr(self.lcd, "clear"):
                    self.lcd.clear()
                for r in range(self.rows):
                    text = lines[r] if r < len(lines) else ""
                    self.lcd.write_line(r, text[:self.cols])
            except Exception as e:
                print("[LCD(write_line) ERROR]", e)

        elif self.mode == "print_line":
            try:
                if hasattr(self.lcd, "clear"):
                    self.lcd.clear()
                for r in range(self.rows):
                    text = lines[r] if r < len(lines) else ""
                    self.lcd.print_line(r, text[:self.cols])
            except Exception as e:
                print("[LCD(print_line) ERROR]", e)

        else:
            # 콘솔 백업
            print("[LCD]")
            for r in range(self.rows):
                text = lines[r] if r < len(lines) else ""
                print(f"{r:02d}| {text[:self.cols]}")

try:
    _ = TextLCD  
except NameError:
    class TextLCD:
        def __init__(self, *a, **kw): pass

lcd = LCDAdapter(i2c, cols=20, rows=4)

hmmd = {
    "present": False,
    "distance_cm": None,
    "speed": None,
    "last_rx_ms": 0,
    "drops": 0,
}

def parse_hmmd_frame(buf: bytes):
    s = buf.decode(errors="ignore")
    present = ('P' in s)
    dist = None
    spd  = None
    if 'D' in s:
        try:
            i = s.index('D') + 1
            dist = int(''.join([c for c in s[i:i+4] if c.isdigit()]))
        except Exception:
            pass
    if 'V' in s:
        try:
            j = s.index('V') + 1
            spd = int(''.join([c for c in s[j:j+3] if c.isdigit()]))
        except Exception:
            pass
    return present, dist, spd

def run_sync_demo(duration_sec=3):
    print("[SYNC] 시작")
    t0 = time.time()
    buf = bytearray()
    while time.time() - t0 < duration_sec:
        # 1) UART 동기 수집
        if uart_mm.any():
            chunk = uart_mm.read()
            if chunk:
                buf.extend(chunk)
                if len(buf) > 64:
                    p, d, v = parse_hmmd_frame(bytes(buf))
                    hmmd["present"] = p
                    if d is not None: hmmd["distance_cm"] = d
                    if v is not None: hmmd["speed"] = v
                    hmmd["last_rx_ms"] = time.ticks_ms()
                    buf.clear()

        stale = time.ticks_diff(time.ticks_ms(), hmmd["last_rx_ms"]) > 1000
        lcd.show([
            f"HMMD: {'YES' if hmmd['present'] else 'NO '}",
            f"Dist: {hmmd['distance_cm']}",
            f"Speed:{hmmd['speed']}",
            f"Stale:{'Y' if stale else 'N'} Drop:{hmmd['drops']}",
        ])


        led.toggle()
        time.sleep(0.2)
    print("[SYNC] 종료")

async def mmwave_task():
    buf = bytearray()
    while True:
        if uart_mm.any():
            chunk = uart_mm.read()
            if chunk:
                buf.extend(chunk)
                if len(buf) > 64:
                    p, d, v = parse_hmmd_frame(bytes(buf))
                    hmmd["present"] = p
                    if d is not None: hmmd["distance_cm"] = d
                    if v is not None: hmmd["speed"] = v
                    hmmd["last_rx_ms"] = time.ticks_ms()
                    buf.clear()
        else:
            await asyncio.sleep_ms(5)

async def lcd_task():
    while True:
        now = time.ticks_ms()
        stale = time.ticks_diff(now, hmmd["last_rx_ms"]) > 1000
        lcd.show([
            f"HMMD: {'YES' if hmmd['present'] else 'NO '}",
            f"Dist: {hmmd['distance_cm']}",
            f"Speed:{hmmd['speed']}",
            f"Stale:{'Y' if stale else 'N'} Drop:{hmmd['drops']}",
        ])
        await asyncio.sleep_ms(200)

async def log_task():
    while True:
        print(f"[LOG] present={hmmd['present']} "
              f"dist={hmmd['distance_cm']} speed={hmmd['speed']}")
        await asyncio.sleep(1)

async def led_task():
    while True:
        led.value(1)
        await asyncio.sleep_ms(100)
        led.value(0)
        await asyncio.sleep_ms(900)

async def main():
    # 필요 시 동기 데모 3초 실행 후 비동기로 전환해 비교 실습
    # run_sync_demo(3)

    await asyncio.gather(
        mmwave_task(),
        lcd_task(),
        log_task(),
        led_task(),
    )

asyncio.run(main())
```

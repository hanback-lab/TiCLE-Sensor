# Environment Sensor 
BME688은 Bosch 사에서 개발한 **온도(Temperature)**, **습도(Humidity)**, **기압(Pressure)**, 그리고 **가스(VOC, Volatile Organic Compounds)** 를 동시에 측정할 수 있는 고성능 환경 센서입니다.  
특히 이 센서는 기존 BME280 센서의 기능에 더하여, 공기 중 유해 가스 농도 변화를 감지하는 **가스 센서 기능**이 추가된 것이 특징입니다.  

BME688은 실내 공기 질, 대기 환경 변화, 기상 관측 및 환기 시스템 등 다양한 분야에 활용할 수 있으며, Raspberry Pi Pico나 ESP32 등과 같은 마이크로컨트롤러 보드에서도 손쉽게 사용할 수 있습니다.  


## Environment Sensor 연결 구성 

| Pin | 연결 대상 | 설명 |
|:---:|:---:|:---|
| 5V | +5V | 전원 |
| GND | GND | 접지 |
| GP0 | SDA | I2C 데이터 |
| GP1 | SCL | I2C 클록 |

![Environment Sensor Connection](res/env%20connection.png)

## Environment Sensor 제어 코드 

```python
from machine import I2C, Pin
import time

class BME688:
    ADDR_LOW  = 0x76
    ADDR_HIGH = 0x77

    REG_CHIP_ID      = 0xD0
    REG_SOFT_RESET   = 0xE0
    REG_STATUS       = 0x1D
    REG_CTRL_HUM     = 0x72
    REG_CTRL_MEAS    = 0x74
    REG_CONFIG       = 0x75
    REG_CTRL_GAS_0   = 0x70
    REG_CTRL_GAS_1   = 0x71
    REG_GAS_WAIT_0   = 0x64
    REG_RES_HEAT_0   = 0x5A
    REG_PRESS_MSB    = 0x1F  
    REG_GAS_R_LSB    = 0x2A  

    CHIP_ID_EXPECTED = 0x61 

    SOFT_RESET_CODE  = 0xB6

    OSRS_SKIP = 0
    OSRS_X1   = 1
    OSRS_X2   = 2
    OSRS_X4   = 3
    OSRS_X8   = 4
    OSRS_X16  = 5

    IIR_OFF = 0
    IIR_1   = 1
    IIR_3   = 2
    IIR_7   = 3
    IIR_15  = 4
    IIR_31  = 5
    IIR_63  = 6
    IIR_127 = 7

    MODE_SLEEP  = 0
    MODE_FORCED = 1

    _LOOKUP_1 = [2147483647, 2147483647, 2147483647, 2147483647,
                 2147483647, 2126008810, 2147483647, 2130303777,
                 2147483647, 2147483647, 2143188679, 2136746228,
                 2147483647, 2126008810, 2147483647, 2147483647]
    _LOOKUP_2 = [4096000000, 2048000000, 1024000000, 512000000,
                 255744255,   127110228,   64000000,    32258064,
                 16016016,      8000000,     4000000,     2000000,
                 1000000,        500000,       250000,      125000]

    def __init__(self, i2c: I2C, addr=None,
                 osrs_t=OSRS_X2, osrs_p=OSRS_X4, osrs_h=OSRS_X2,
                 iir=IIR_7, heater_temp=320, heater_time_ms=150):
        self.i2c = i2c
        self.addr = addr or self._auto_addr()
        chip_id = self._r8(self.REG_CHIP_ID)
        if chip_id != self.CHIP_ID_EXPECTED:
            raise OSError("Unexpected CHIP_ID: 0x%02X" % chip_id)

        self._soft_reset()
        time.sleep_ms(10)

        self._read_calibration()

        self.osrs_t = osrs_t
        self.osrs_p = osrs_p
        self.osrs_h = osrs_h
        self.iir = iir

        self._w8(self.REG_CTRL_GAS_1, 0x00)
        self._w8(self.REG_CTRL_HUM, self.osrs_h & 0x07)

        config = (self.iir & 0x07) << 2
        self._w8(self.REG_CONFIG, config)

        ctrl_meas = ((self.osrs_t & 0x07) << 5) | ((self.osrs_p & 0x07) << 2) | self.MODE_SLEEP
        self._w8(self.REG_CTRL_MEAS, ctrl_meas)

        self.set_gas_heater(heater_temp, heater_time_ms)
        self._w8(self.REG_CTRL_GAS_1, 0x10)

    def _r8(self, reg):
        return self.i2c.readfrom_mem(self.addr, reg, 1)[0]
    def _w8(self, reg, val):
        self.i2c.writeto_mem(self.addr, reg, bytes([val]))
    def _rs(self, reg, n):
        return self.i2c.readfrom_mem(self.addr, reg, n)

    def _auto_addr(self):
        scan = self.i2c.scan()
        for cand in (self.ADDR_LOW, self.ADDR_HIGH):
            if cand in scan:
                return cand
        raise OSError("BME688 not found on I2C (0x76/0x77). Check wiring.")

    def _soft_reset(self):
        self._w8(self.REG_SOFT_RESET, self.SOFT_RESET_CODE)

    def _read_calibration(self):
        r8 = self._r8

        par_t1 = (r8(0xEA) << 8) | r8(0xE9)
        par_t2 = (r8(0x8B) << 8) | r8(0x8A)
        par_t3 = r8(0x8C)                  

        par_p1 = (r8(0x8F) << 8) | r8(0x8E)
        par_p2 = (r8(0x91) << 8) | r8(0x90)
        par_p3 = r8(0x92)                  
        par_p4 = (r8(0x95) << 8) | r8(0x94)
        par_p5 = (r8(0x97) << 8) | r8(0x96)
        par_p6 = r8(0x99)                  
        par_p7 = r8(0x98)                  
        par_p8 = (r8(0x9D) << 8) | r8(0x9C)
        par_p9 = (r8(0x9F) << 8) | r8(0x9E)
        par_p10= r8(0xA0)                  

        e1, e2, e3 = r8(0xE1), r8(0xE2), r8(0xE3)
        par_h1 = (e2 << 4) | (e3 & 0x0F)
        par_h2 = (e1 << 4) | (e3 >> 4)  
        par_h3 = r8(0xE4)               
        par_h4 = r8(0xE5)               
        par_h5 = r8(0xE6)               
        par_h6 = r8(0xE7)               
        par_h7 = r8(0xE8)               

        par_gh1 = r8(0xED)                   
        par_gh2 = (r8(0xEC) << 8) | r8(0xEB) 
        par_gh3 = r8(0xEE)                   

        res_heat_range = (r8(0x02) & 0x30) >> 4
        res_heat_val   = r8(0x00)
        range_sw_err   = (r8(0x04) & 0xF0) >> 4

        s8  = lambda v: v-256 if v>127 else v
        s12 = lambda v: v-4096 if v>2047 else v
        s16 = lambda v: v-65536 if v>32767 else v

        self.par_t1  = par_t1
        self.par_t2  = s16(par_t2)
        self.par_t3  = s8(par_t3)

        self.par_p1  = par_p1
        self.par_p2  = s16(par_p2)
        self.par_p3  = s8(par_p3)
        self.par_p4  = s16(par_p4)
        self.par_p5  = s16(par_p5)
        self.par_p6  = s8(par_p6)
        self.par_p7  = s8(par_p7)
        self.par_p8  = s16(par_p8)
        self.par_p9  = s16(par_p9)
        self.par_p10 = s8(par_p10)

        self.par_h1  = par_h1
        self.par_h2  = s12(par_h2)
        self.par_h3  = s8(par_h3)
        self.par_h4  = s8(par_h4)
        self.par_h5  = s8(par_h5)
        self.par_h6  = s8(par_h6)
        self.par_h7  = s8(par_h7)

        self.par_gh1 = s8(par_gh1)
        self.par_gh2 = s16(par_gh2)
        self.par_gh3 = s8(par_gh3)

        self.res_heat_range = res_heat_range
        self.res_heat_val   = s8(res_heat_val)
        self.range_sw_err   = s8(range_sw_err)
        self.t_fine = 0

    def set_gas_heater(self, target_temp_c=320, heat_time_ms=150):
        res_heat = self._calc_res_heat(target_temp_c)
        self._w8(self.REG_RES_HEAT_0, res_heat & 0xFF)
        gas_wait = self._encode_gas_wait(heat_time_ms)
        self._w8(self.REG_GAS_WAIT_0, gas_wait & 0xFF)

    def _calc_res_heat(self, target_temp_c):
        ambient = self.read_temperature_fast()
        if ambient is None:
            ambient = 25.0

        var1 = (self.par_gh1 / 16.0) + 49.0
        var2 = ((self.par_gh2 / 32768.0) * 0.0005) + 0.00235
        var3 = self.par_gh3 / 1024.0
        var4 = var1 * (1.0 + var2 * target_temp_c)
        var5 = var4 + (var3 * ambient)
        res_heat_x100 = int( ( (var5 * 4.0) / (1.0 + (self.res_heat_range * 0.002))) - 25 )
        res_heat = int((res_heat_x100 * 100) / (100 + self.res_heat_val))
        if res_heat < 0: res_heat = 0
        if res_heat > 255: res_heat = 255
        return res_heat

    def _encode_gas_wait(self, ms):
        if ms <= 0: return 0
        factor = 0
        base = ms
        while base > 63 and factor < 3:
            base = (base + 1) >> 1
            factor += 1
        if base > 63: base = 63
        return (factor << 6) | (base & 0x3F)

    def _set_forced_mode_once(self):
        ctrl_hum = self.osrs_h & 0x07
        self._w8(self.REG_CTRL_HUM, ctrl_hum)
        ctrl_meas = ((self.osrs_t & 0x07) << 5) | ((self.osrs_p & 0x07) << 2) | self.MODE_FORCED
        self._w8(self.REG_CTRL_MEAS, ctrl_meas)

    def _meas_duration_ms(self):
        t = 1.25 + (2.3 * self.osrs_t) + (2.3 * self.osrs_p + 0.575) + (2.3 * self.osrs_h + 0.575)
        gas_wait = self._r8(self.REG_GAS_WAIT_0)
        wait_ms = (gas_wait & 0x3F) * (1 << (gas_wait >> 6))
        return int(t + wait_ms + 10)

    def measure(self):
        self._set_forced_mode_once()
        time.sleep_ms(self._meas_duration_ms())

        data = self._rs(self.REG_PRESS_MSB, 7)
        p_raw = ((data[0] << 12) | (data[1] << 4) | (data[2] >> 4)) & 0xFFFFF
        t_raw = ((data[3] << 12) | (data[4] << 4) | (data[5] >> 4)) & 0xFFFFF
        h_raw = (data[6] << 8) | self._r8(self.REG_PRESS_MSB + 7)

        gas_raw_bytes = self._rs(self.REG_GAS_R_LSB, 3)
        gas_r_raw = (gas_raw_bytes[0] | (gas_raw_bytes[1] << 2)) & 0x3FFF
        gas_range  = gas_raw_bytes[2] & 0x0F

        temp_c = self._compensate_temp(t_raw)
        press_pa = self._compensate_press(p_raw)
        hum_rh = self._compensate_hum(h_raw)
        gas_ohm = self._calc_gas_resistance(gas_r_raw, gas_range)

        return {
            "temperature_c": temp_c,
            "pressure_pa":   press_pa,
            "pressure_hpa":  press_pa / 100.0,
            "humidity_rh":   hum_rh,
            "gas_resistance_ohm": gas_ohm,
        }

    def read_temperature_fast(self):
        try:
            self._set_forced_mode_once()
            time.sleep_ms(80)
            data = self._rs(self.REG_PRESS_MSB + 3, 3)
            t_raw = ((data[0] << 12) | (data[1] << 4) | (data[2] >> 4)) & 0xFFFFF
            return self._compensate_temp(t_raw)
        except:
            return None

    def _compensate_temp(self, adc_t):
        var1 = (adc_t / 16384.0 - self.par_t1 / 1024.0) * self.par_t2
        var2 = ((adc_t / 131072.0 - self.par_t1 / 8192.0) * (adc_t / 131072.0 - self.par_t1 / 8192.0)) * self.par_t3 * 16.0
        self.t_fine = var1 + var2
        t = self.t_fine / 5120.0
        return t

    def _compensate_press(self, adc_p):
        var1 = (self.t_fine / 2.0) - 64000.0
        var2 = var1 * var1 * (self.par_p6 / 131072.0)
        var2 = var2 + (var1 * self.par_p5 * 2.0)
        var2 = (var2 / 4.0) + (self.par_p4 * 65536.0)
        var1 = ((self.par_p3 * var1 * var1 / 16384.0) + (self.par_p2 * var1)) / 524288.0
        var1 = (1.0 + var1/32768.0) * self.par_p1
        if var1 == 0:
            return 0
        p = 1048576.0 - adc_p
        p = (p - (var2 / 4096.0)) * 6250.0 / var1
        var1 = self.par_p9 * p * p / 2147483648.0
        var2 = p * self.par_p8 / 32768.0
        var3 = (p / 256.0) ** 3 * (self.par_p10 / 131072.0)
        p = p + (var1 + var2 + var3 + (self.par_p7 * 128.0)) / 16.0
        return p

    def _compensate_hum(self, adc_h):
        temp = self.t_fine / 5120.0
        var1 = adc_h - (self.par_h1 * 16.0 + (self.par_h3 / 2.0) * temp)
        var2 = var1 * ( (self.par_h2 / 262144.0) * (1.0 + (self.par_h4 / 16384.0) * temp + (self.par_h5 / 1048576.0) * temp * temp) )
        var3 = self.par_h6 / 16384.0
        var4 = self.par_h7 / 2097152.0
        h = var2 + ((var3 + var4 * temp) * var2 * var2)
        if h > 100.0: h = 100.0
        if h < 0.0:   h = 0.0
        return h

    def _calc_gas_resistance(self, gas_adc, gas_range):
        var1 = 1340 + 5 * self.range_sw_err
        var2 = var1 * self._LOOKUP_1[gas_range] / 65536
        var3 = int((gas_adc * 32768) - 16777216) + var2
        var4 = (self._LOOKUP_2[gas_range] * var1) / 512
        gas_res = 0.0
        if var3 != 0:
            gas_res = (var4 / var3) * 1.0
        return gas_res

    @staticmethod
    def altitude_from_pressure(pressure_pa, sea_level_pa=101325.0):
        return 44330.0 * (1.0 - pow(pressure_pa / sea_level_pa, 0.1903))

def main():
    i2c = I2C(0, sda=Pin(0), scl=Pin(1), freq=400_000)

    try:
        bme = BME688(i2c,osrs_t=BME688.OSRS_X2,osrs_p=BME688.OSRS_X4,osrs_h=BME688.OSRS_X2,iir=BME688.IIR_7,heater_temp=320,heater_time_ms=150)
    except Exception as e:
        print("BME688 init failed:", e)
        return

    print("BME688 ready. Ctrl+C to stop.")
    sea_level_pa = 101325.0

    while True:
        try:
            m = bme.measure()
            alt = BME688.altitude_from_pressure(m["pressure_pa"], sea_level_pa)
            print("T={:.2f}°C  RH={:.2f}%  P={:.2f} hPa  Gas={:.0f} Ω  Alt≈{:.1f} m".format(
                m["temperature_c"], m["humidity_rh"], m["pressure_hpa"],
                m["gas_resistance_ohm"], alt))
            time.sleep(1.0)
        except KeyboardInterrupt:
            print("\nStop.")
            break
        except OSError as e:
            print("I2C error:", e)
            time.sleep(0.5)

if __name__ == "__main__":
    main()
```


# RFID
RFID(Radio Frequency Identification) 기술은 무선 주파수를 이용하여 태그(Tag)에 저장된 정보를 비접촉 방식으로 읽어내는 기술입니다.  
이 시스템은 크게 **리더기(Reader)** 와 **태그(Tag)** 로 구성되며, 카드나 열쇠고리 형태의 태그가 많이 사용됩니다.  

### RFID 동작 원리 

1. **전원 인가 후 초기화** — SPI 통신으로 MFRC522를 초기화합니다.  
2. **카드 탐색 (REQA)** — 근처에 있는 카드가 있는지 확인합니다.  
3. **UID(고유 식별 번호) 읽기** — 충돌 방지(anticollision) 과정을 통해 UID를 가져옵니다.  
4. **카드 선택 (SELECT)** — 읽은 UID를 이용해 대상 카드를 선택합니다.  
5. **(옵션) 데이터 블록 접근** — MIFARE Classic 카드의 특정 블록을 인증 후 읽습니다.  

## RFID 연결 구성 
| Pin 번호 | 연결 대상 | 설명 |
|-------------|------------|------|
| SDA (SS) | GP17 | SPI Chip Select (CS) |
| SCK | GP18 | SPI Clock |
| MOSI | GP19 | SPI Master Out |
| MISO | GP16 | SPI Master In |
| RST | (사용하지 않음) | RC522 내부 리셋 기능으로 대체 |
| 5V | 5V | 전원 |
| GND | GND | 공통 접지 |

## RFID 제어 코드 

```python
from machine import Pin, SPI
import time

PIN_SCK  = 18
PIN_MOSI = 19
PIN_MISO = 16
PIN_CS   = 17

SPI_ID   = 0
SPI_BAUD = 4_000_000 

TEST_BLOCK = 8
KEY_A = b"\xff\xff\xff\xff\xff\xff"

class RFID:
    CommandReg      = 0x01
    ComIEnReg       = 0x02
    DivIEnReg       = 0x03
    ComIrqReg       = 0x04
    DivIrqReg       = 0x05
    ErrorReg        = 0x06
    Status1Reg      = 0x07
    Status2Reg      = 0x08
    FIFODataReg     = 0x09
    FIFOLevelReg    = 0x0A
    ControlReg      = 0x0C
    BitFramingReg   = 0x0D
    ModeReg         = 0x11
    TxControlReg    = 0x14
    TxASKReg        = 0x15
    CRCResultRegH   = 0x21
    CRCResultRegL   = 0x22
    TModeReg        = 0x2A
    TPrescalerReg   = 0x2B
    TReloadRegH     = 0x2C
    TReloadRegL     = 0x2D

    PCD_Idle        = 0x00
    PCD_CalcCRC     = 0x03
    PCD_Transceive  = 0x0C
    PCD_SoftReset   = 0x0F
    PCD_MFAuthent   = 0x0E

    PICC_REQIDL     = 0x26
    PICC_ANTICOLL   = 0x93
    PICC_SELECTTAG  = 0x93
    PICC_HLTA       = 0x50
    PICC_AUTH_KEYA  = 0x60
    PICC_READ       = 0x30

    def __init__(self, spi: SPI, cs: Pin):
        self.spi = spi
        self.cs = cs
        self.cs.init(Pin.OUT, value=1)

        self.reset()
        self._wreg(self.TModeReg, 0x8D)
        self._wreg(self.TPrescalerReg, 0x3E)
        self._wreg(self.TReloadRegL, 30)
        self._wreg(self.TReloadRegH, 0)
        self._wreg(self.TxASKReg, 0x40)
        self._wreg(self.ModeReg, 0x3D)
        self.antenna_on()

    def _rreg(self, addr):
        self.cs.value(0)
        self.spi.write(bytearray([0x80 | ((addr << 1) & 0x7E)]))
        val = self.spi.read(1, 0x00)[0]
        self.cs.value(1)
        return val

    def _wreg(self, addr, val):
        self.cs.value(0)
        self.spi.write(bytearray([((addr << 1) & 0x7E), val & 0xFF]))
        self.cs.value(1)

    def set_bitmask(self, reg, mask):
        self._wreg(reg, self._rreg(reg) | mask)

    def clear_bitmask(self, reg, mask):
        self._wreg(reg, self._rreg(reg) & (~mask & 0xFF))

    def reset(self):
        self._wreg(self.CommandReg, self.PCD_SoftReset)
        time.sleep_ms(50)
        self._wreg(self.FIFOLevelReg, 0x80)

    def antenna_on(self):
        if (self._rreg(self.TxControlReg) & 0x03) != 0x03:
            self.set_bitmask(self.TxControlReg, 0x03)

    def calc_crc(self, data: bytes):
        self._wreg(self.CommandReg, self.PCD_Idle)
        self._wreg(self.DivIrqReg, 0x04)
        self._wreg(self.FIFOLevelReg, 0x80)
        for b in data:
            self._wreg(self.FIFODataReg, b)
        self._wreg(self.CommandReg, self.PCD_CalcCRC)
        for _ in range(5000):
            if self._rreg(self.DivIrqReg) & 0x04:
                break
        lo = self._rreg(self.CRCResultRegL)
        hi = self._rreg(self.CRCResultRegH)
        return bytes([lo, hi])

    def transceive(self, data: bytes, wait_irq=0x30, timeout_us=3000):
        self._wreg(self.ComIrqReg, 0x7F)
        self._wreg(self.FIFOLevelReg, 0x80)
        self._wreg(self.CommandReg, self.PCD_Idle)
        for b in data:
            self._wreg(self.FIFODataReg, b)
        self._wreg(self.CommandReg, self.PCD_Transceive)
        self.set_bitmask(self.BitFramingReg, 0x80)  # StartSend

        t0 = time.ticks_us()
        while True:
            irq = self._rreg(self.ComIrqReg)
            if irq & wait_irq:
                break
            if time.ticks_diff(time.ticks_us(), t0) > timeout_us:
                self.clear_bitmask(self.BitFramingReg, 0x80)
                return None, 0, 0x01  # timeout
        self.clear_bitmask(self.BitFramingReg, 0x80)

        if self._rreg(self.ErrorReg) & 0x1B:
            return None, 0, 0x02      # error

        n = self._rreg(self.FIFOLevelReg)
        out = bytearray()
        for _ in range(n):
            out.append(self._rreg(self.FIFODataReg))

        last_bits = self._rreg(self.ControlReg) & 0x07
        valid_bits = (n - 1) * 8 + last_bits if last_bits else n * 8
        return bytes(out), valid_bits, 0

    def reqa(self):
        self._wreg(self.BitFramingReg, 0x07)
        res, bits, err = self.transceive(bytes([self.PICC_REQIDL]))
        self._wreg(self.BitFramingReg, 0x00)
        if err == 0 and bits == 16 and res and len(res) == 2:
            return res
        return None

    def anticollision(self):
        self._wreg(self.BitFramingReg, 0x00)
        res, bits, err = self.transceive(bytes([self.PICC_ANTICOLL, 0x20]))
        if err != 0 or not res or len(res) != 5:
            return None
        uid = res[:4]
        if (uid[0] ^ uid[1] ^ uid[2] ^ uid[3]) != res[4]:
            return None
        return uid

    def select(self, uid: bytes):
        bcc = uid[0] ^ uid[1] ^ uid[2] ^ uid[3]
        frame = bytes([self.PICC_SELECTTAG, 0x70]) + uid + bytes([bcc])
        crc = self.calc_crc(frame)
        res, bits, err = self.transceive(frame + crc)
        if err == 0 and res and len(res) == 3:
            return res[0]  
        return None

    def halt(self):
        frame = bytes([self.PICC_HLTA, 0x00])
        crc = self.calc_crc(frame)
        self.transceive(frame + crc)

    def auth_key_a(self, block_no: int, uid: bytes, key_a: bytes):
        self._wreg(self.CommandReg, self.PCD_Idle)
        self._wreg(self.FIFOLevelReg, 0x80)
        frame = bytearray([self.PICC_AUTH_KEYA, block_no & 0xFF])
        frame += key_a[:6]
        frame += uid[:4]
        for b in frame:
            self._wreg(self.FIFODataReg, b)
        self._wreg(self.CommandReg, self.PCD_MFAuthent)
        t0 = time.ticks_ms()
        while not (self._rreg(self.Status2Reg) & 0x08):
            if time.ticks_diff(time.ticks_ms(), t0) > 50:
                return False
        return True

    def stop_crypto(self):
        self.clear_bitmask(self.Status2Reg, 0x08)

    def read_block(self, block_no: int):
        frame = bytes([self.PICC_READ, block_no & 0xFF])
        crc = self.calc_crc(frame)
        res, bits, err = self.transceive(frame + crc, timeout_us=6000)
        if err != 0 or not res or len(res) < 16:
            return None
        return bytes(res[:16])

def main():
    spi = SPI(SPI_ID, baudrate=SPI_BAUD, polarity=0, phase=0,
              sck=Pin(PIN_SCK), mosi=Pin(PIN_MOSI), miso=Pin(PIN_MISO))
    cs  = Pin(PIN_CS, Pin.OUT)

    rc = RFID(spi, cs)
    print("RC522 ready (RST pin not used). Bring a tag near the antenna. Ctrl+C to stop.")

    last_uid = None
    while True:
        try:
            if rc.reqa():
                uid = rc.anticollision()
                if uid:
                    if uid != last_uid:
                        print("Card detected. UID =", uid.hex())
                        last_uid = uid
                    sak = rc.select(uid)
                    if sak is not None:
                        print("SAK=0x%02X" % sak)
                        if rc.auth_key_a(TEST_BLOCK, uid, KEY_A):
                            data = rc.read_block(TEST_BLOCK)
                            rc.stop_crypto()
                            if data:
                                print("Block %d:" % TEST_BLOCK, data.hex())
                            else:
                                print("Read block failed.")
                        else:
                            print("Auth(A) failed (block %d)" % TEST_BLOCK)
                    rc.halt()
                else:
                    time.sleep_ms(50)
            else:
                last_uid = None
                time.sleep_ms(120)
        except KeyboardInterrupt:
            print("\nStop.")
            break
        except Exception as e:
            print("Error:", e)
            time.sleep_ms(200)

if __name__ == "__main__":
    main()
```

<details>
<summary>심화 학습</summary>

## 